<!DOCTYPE html><head><meta charset="UTF-8"><title>InterfaceKernels System | Chamois</title><link rel="icon" type="image/x-icon" href="../../media/chamois_logo.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down">Chamois</a><a href="https://github.com/matthiasneuner/chamois" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../getting_started.html">Getting Started</a></li><li><a href="../../singularity.html">Singularity container</a></li><li><a href="../../publications.html">Publications</a></li><li><a href="../../contributors.html">Contributors</a></li><li><a href="#!" class="dropdown-trigger" data-target="84d2d1f3-d335-4373-a3a9-c6a65cebbd77" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li></ul><a href="#" class="sidenav-trigger" data-target="662eed04-8515-4e74-a96d-7ba5320a6a3e"><i class="material-icons">menu</i></a><ul class="sidenav" id="662eed04-8515-4e74-a96d-7ba5320a6a3e"><li><a href="../../getting_started.html">Getting Started</a></li><li><a href="../../singularity.html">Singularity container</a></li><li><a href="../../publications.html">Publications</a></li><li><a href="../../contributors.html">Contributors</a></li><li><a href="#!" class="dropdown-trigger" data-target="aa12d42e-58fc-46ae-b196-f1af6cc3223c" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="84d2d1f3-d335-4373-a3a9-c6a65cebbd77"><li><a href="../chamois.html">Chamois syntax</a></li></ul><ul class="dropdown-content" id="aa12d42e-58fc-46ae-b196-f1af6cc3223c"><li><a href="../chamois.html">Chamois syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="a55d6c55-47cf-4db3-8d81-de6019c63c1d" data-section-level="1" data-section-text="InterfaceKernels System"><h1 id="interfacekernels-system">InterfaceKernels System</h1><p>Interface kernels are meant to assist in coupling different physics across sub-domains. The most straightforward example is the case in which one wants to set the flux of a specie A in subdomain 0 equal to the flux of a specie B in subdomain 1 at the boundary between subdomains 0 and 1. In mathematical terms, we might be interested in establishing the condition:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-a642433c-0ba9-40fe-b320-6447fad60797"></span><script>var element = document.getElementById("moose-equation-a642433c-0ba9-40fe-b320-6447fad60797");katex.render("-D_0 \\frac{\\partial c_0}{\\partial x} = -D_1 \\frac{\\partial c_1}{\\partial x}", element, {displayMode:true,throwOnError:false});</script></span></p><p>where <span class="moose-katex-inline-equation" id="moose-equation-050ace7a-7aa2-42e5-939b-ff7e097e1a88"><script>var element = document.getElementById("moose-equation-050ace7a-7aa2-42e5-939b-ff7e097e1a88");katex.render("D_i", element, {displayMode:false,throwOnError:false});</script></span> is the diffusion coefficient of specie <span class="moose-katex-inline-equation" id="moose-equation-71c0bdba-308c-4c4d-82d1-cd4383289f45"><script>var element = document.getElementById("moose-equation-71c0bdba-308c-4c4d-82d1-cd4383289f45");katex.render("i", element, {displayMode:false,throwOnError:false});</script></span> in subdomain <span class="moose-katex-inline-equation" id="moose-equation-970acf98-bfa8-4052-971a-b994cac64ac4"><script>var element = document.getElementById("moose-equation-970acf98-bfa8-4052-971a-b994cac64ac4");katex.render("i", element, {displayMode:false,throwOnError:false});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-e68f2c19-4689-4beb-87bd-aa577d7ed613"><script>var element = document.getElementById("moose-equation-e68f2c19-4689-4beb-87bd-aa577d7ed613");katex.render("c_i", element, {displayMode:false,throwOnError:false});</script></span> is the concentration of specie <span class="moose-katex-inline-equation" id="moose-equation-ec927af1-3327-4785-9e0d-8180ec9f0aa4"><script>var element = document.getElementById("moose-equation-ec927af1-3327-4785-9e0d-8180ec9f0aa4");katex.render("i", element, {displayMode:false,throwOnError:false});</script></span> in subdomain <span class="moose-katex-inline-equation" id="moose-equation-788574a2-4d3f-4677-8ae4-58e765202955"><script>var element = document.getElementById("moose-equation-788574a2-4d3f-4677-8ae4-58e765202955");katex.render("i", element, {displayMode:false,throwOnError:false});</script></span>. An example of this condition is shown in the MOOSE test directory; see files below:</p><p><a class="moose-source-filename tooltipped modal-trigger" href="#4621e7c3-3e09-466e-8d39-7d00b255e81d">(moose/test/tests/interfacekernels/2d_interface/coupled_value_coupled_flux.i)</a></p><p><a class="moose-source-filename tooltipped modal-trigger" href="#7177a45b-184e-4556-bc7b-c35cfac69b0b">(moose/framework/src/interfacekernels/InterfaceDiffusion.C)</a></p><p><a class="moose-source-filename tooltipped modal-trigger" href="#ef9b89be-52e0-483d-a4e2-b9b1aa25b7ab">(moose/framework/include/interfacekernels/InterfaceDiffusion.h)</a></p><p>Interface kernels can be used to provide any general flux condition at an interface, and even more generally can be used to impose any interfacial condition that requires access to values of different variables and gradients of different variables on either side of an interface. In an input file, the user will specify at a minimum the following parameters:</p><ul class="browser-default"><li><p><code>type</code>: The type of interface kernel to be used </p></li><li><p><code>variable</code>: This is the &quot;primary&quot; variable. Note that the primary variable must exist on the same subdomain as the sideset specified in the <code>boundary</code> parameter. The existence of a &quot;primary&quot; and &quot;secondary&quot; or &quot;neighbor&quot; variable ensures that the interface kernel residual and jacobian functions get called the correct number of times. <code>variable</code> could be <span class="moose-katex-inline-equation" id="moose-equation-57ac6f23-87bb-445c-8386-87b1b5c85929"><script>var element = document.getElementById("moose-equation-57ac6f23-87bb-445c-8386-87b1b5c85929");katex.render("c_0", element, {displayMode:false,throwOnError:false});</script></span> from our example above. </p></li><li><p><code>neighbor_var</code>: The &quot;secondary&quot; variable. This could be <span class="moose-katex-inline-equation" id="moose-equation-45af3168-fbb9-4422-97dd-8a61bac8c5e7"><script>var element = document.getElementById("moose-equation-45af3168-fbb9-4422-97dd-8a61bac8c5e7");katex.render("c_1", element, {displayMode:false,throwOnError:false});</script></span> from our example above. </p></li><li><p><code>boundary</code>: The interfacial boundary between the subdomains. Note that this must be a sideset and again must exist on the same subdomain as the primary variable. The fact that this boundary is a sideset allows access to variable gradients.</p></li></ul><p>An important private parameter relevant to displaced mesh calculations is <code>_use_undisplaced_reference_points</code>. If an interface kernel developer sets this parameter to <code>true</code> in the <code>validParams</code> of their derived class, then the displaced problem will use the neighbor reference points computed by the undisplaced problem as the neighbor reference points for the displaced problem. If this parameter is <code>false</code> (the default), then the neighbor reference points on the displaced problem will be computed in the traditional way: by doing an inverse map of the physical locations of the displaced <strong>element</strong> reference points. Here, reference refers to the reference coordinates (e.g. <span class="moose-katex-inline-equation" id="moose-equation-f8efabf9-999f-4d3a-a994-0e3281d8cc45"><script>var element = document.getElementById("moose-equation-f8efabf9-999f-4d3a-a994-0e3281d8cc45");katex.render("\\xi", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-a001780e-196c-442e-82ba-754212265b41"><script>var element = document.getElementById("moose-equation-a001780e-196c-442e-82ba-754212265b41");katex.render("\\eta", element, {displayMode:false,throwOnError:false});</script></span>) of the quadrature points and physical refers to the physical coordinates (e.g. <span class="moose-katex-inline-equation" id="moose-equation-db9bb4b3-9579-43b9-9d53-fafa1669b179"><script>var element = document.getElementById("moose-equation-db9bb4b3-9579-43b9-9d53-fafa1669b179");katex.render("x", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-fc31ef5c-a9dd-4829-8906-d32689baf23c"><script>var element = document.getElementById("moose-equation-fc31ef5c-a9dd-4829-8906-d32689baf23c");katex.render("y", element, {displayMode:false,throwOnError:false});</script></span>) of the quadrature points.</p><p>For additional information about the interface kernel system, don&#x27;t hesitate to contact the <a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion forum</a>.</p><section id="4a3dae62-27b0-46d8-a5ac-5dfec6079ba0" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/interfacekernels/InterfaceDiffusion.html">InterfaceDiffusion</a>The kernel is utilized to establish flux equivalence on an interface for variables.</li><li class="collection-item"><a href="../../source/interfacekernels/InterfaceReaction.html">InterfaceReaction</a>Implements a reaction to establish ReactionRate=k_f*u-k_b*v at interface.</li><li class="collection-item"><a href="../../source/interfacekernels/PenaltyInterfaceDiffusion.html">PenaltyInterfaceDiffusion</a>A penalty-based interface condition that forcesthe continuity of variables and the flux equivalence across an interface.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="../../source/interfacekernels/CZMInterfaceKernelSmallStrain.html">CZMInterfaceKernelSmallStrain</a>CZM Interface kernel to use when using the Small Strain kinematic formulation.</li><li class="collection-item"><a href="../../source/interfacekernels/CZMInterfaceKernelTotalLagrangian.html">CZMInterfaceKernelTotalLagrangian</a></li></ul></section><section id="915bf346-39e3-49e6-93af-056ace254546" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddInterfaceKernelAction.html">AddInterfaceKernelAction</a>Add an InterfaceKernel object to the simulation.</li></ul></section></section><div class="moose-modal modal" id="4621e7c3-3e09-466e-8d39-7d00b255e81d"><div class="modal-content"><h4>(moose/test/tests/interfacekernels/2d_interface/coupled_value_coupled_flux.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 0
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 1
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="7177a45b-184e-4556-bc7b-c35cfac69b0b"><div class="modal-content"><h4>(moose/framework/src/interfacekernels/InterfaceDiffusion.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;InterfaceDiffusion.h&quot;

registerMooseObject(&quot;MooseApp&quot;, InterfaceDiffusion);

InputParameters
InterfaceDiffusion::validParams()
{
  InputParameters params = InterfaceKernel::validParams();
  params.addParam&lt;MaterialPropertyName&gt;(&quot;D&quot;, &quot;D&quot;, &quot;The diffusion coefficient.&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;D_neighbor&quot;, &quot;D_neighbor&quot;, &quot;The neighboring diffusion coefficient.&quot;);
  params.addClassDescription(
      &quot;The kernel is utilized to establish flux equivalence on an interface for variables.&quot;);
  return params;
}

InterfaceDiffusion::InterfaceDiffusion(const InputParameters &amp; parameters)
  : InterfaceKernel(parameters),
    _D(getMaterialProperty&lt;Real&gt;(&quot;D&quot;)),
    _D_neighbor(getNeighborMaterialProperty&lt;Real&gt;(&quot;D_neighbor&quot;))
{
}

Real
InterfaceDiffusion::computeQpResidual(Moose::DGResidualType type)
{
  Real r = 0;

  switch (type)
  {
    case Moose::Element:
      r = _test[_i][_qp] * -_D_neighbor[_qp] * _grad_neighbor_value[_qp] * _normals[_qp];
      break;

    case Moose::Neighbor:
      r = _test_neighbor[_i][_qp] * _D[_qp] * _grad_u[_qp] * _normals[_qp];
      break;
  }

  return r;
}

Real
InterfaceDiffusion::computeQpJacobian(Moose::DGJacobianType type)
{
  Real jac = 0;

  switch (type)
  {
    case Moose::ElementElement:
    case Moose::NeighborNeighbor:
      break;

    case Moose::NeighborElement:
      jac = _test_neighbor[_i][_qp] * _D[_qp] * _grad_phi[_j][_qp] * _normals[_qp];
      break;

    case Moose::ElementNeighbor:
      jac = _test[_i][_qp] * -_D_neighbor[_qp] * _grad_phi_neighbor[_j][_qp] * _normals[_qp];
      break;
  }

  return jac;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ef9b89be-52e0-483d-a4e2-b9b1aa25b7ab"><div class="modal-content"><h4>(moose/framework/include/interfacekernels/InterfaceDiffusion.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;InterfaceKernel.h&quot;

/**
 * DG kernel for interfacing diffusion between two variables on adjacent blocks
 */
class InterfaceDiffusion : public InterfaceKernel
{
public:
  static InputParameters validParams();

  InterfaceDiffusion(const InputParameters &amp; parameters);

protected:
  virtual Real computeQpResidual(Moose::DGResidualType type) override;
  virtual Real computeQpJacobian(Moose::DGJacobianType type) override;

  const MaterialProperty&lt;Real&gt; &amp; _D;
  const MaterialProperty&lt;Real&gt; &amp; _D_neighbor;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>